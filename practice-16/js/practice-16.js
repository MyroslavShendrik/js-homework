//! 3.Ланцюжки методів
//? ✳️ У нас є масив об'єктів з іменами, балами і відвідуваними предметами кожного студента.
const students = [
    { name: "Манго", score: 83, courses: ["математика", "фізика"] },
    { name: "Полі", score: 59, courses: ["інформатика", "математика"] },
    { name: "Аякс", score: 37, courses: ["фізика", "біологія"] },
    { name: "Ківі", score: 94, courses: ["література", "інформатика"] },
];

//? ✳️ Необхідно отримати масив їхніх імен,
//? відсортованих за зростанням балів за тест.
//? З цією метою ми відсортуємо копію масиву методом sort(),
//? після чого методом map() створимо масив значень властивості name
//? з відсортованого масиву.
const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
const names1 = sortedByAscendingScore.map(student => student.name);

console.log("names1:", names1); //! ['Аякс', 'Полі', 'Манго', 'Ківі']
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . .");

//? ✳️ Проблема в тому, що у нас з'являються проміжні змінні
//? після кожної операції, крім фінальної.
//? Змінна sortedByAscendingScore - зайва
//? і необхідна тільки для зберігання проміжного результату.
//? ✳️ Позбутися таких «мертвих» змінних можна
//? за допомогою групування викликів методів у ланцюжку.
//? Кожний наступний метод буде виконуватися
//? на основі результату роботи попереднього.
//? 🔸 Робимо копію вихідного масиву перед сортуванням.
//? 🔸 На копії викликаємо метод sort().
//? 🔸 До результату роботи методу sort() застосовуємо метод map().
//? 🔸 Змінній names присвоюється результат роботи методу map().

const names2 = [...students]
    .sort((a, b) => a.score - b.score)
    .map(student => student.name);

console.log("names2:", names2); //! ['Аякс', 'Полі', 'Манго', 'Ківі']
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . .");

//? ✳️ Отримаємо масив унікальних відвідуваних предметів, відсортований за алфавітом.
//? 🔸 На вихідному масиві викликаємо flatMap() і робимо розгладжений масив усіх курсів.
//? 🔸 До результату методу flatMap() застосовуємо метод filter() для фільтрації унікальних елементів.
//? 🔸 На результаті методу filter() викликаємо sort().
//? 🔸 Змінній uniqueSortedCourses присвоюється результат роботи методу sort().
const uniqueSortedCourses = students
    .flatMap(student => student.courses)
    .filter((course, index, array) => array.indexOf(course) === index)
    .sort((a, b) => a.localeCompare(b));

console.log("uniqueSortedCourses:", uniqueSortedCourses);  //! ['біологія', 'інформатика', 'література', 'математика', 'фізика']
console.log("----------------------------------------------------------------------------------------------");

//? ✳️ Ланцюжок методів може бути довільної довжини,
//? але, зазвичай, не більше 2-3 операцій.
//? 🔷 По-перше, перебираючі методи використовуються
//? для порівняно простих операцій над колекцією.
//? 🔷 По-друге, виклик кожного наступного методу 
//? - це додаткове перебирання масиву, 
//? що за великої кількості, 
//? може позначитися на продуктивності.

//! 1.Метод reduce()
console.warn("Синтаксис методу reduce():");
//? ✴️ Метод reduce(callback, initialValue)
//? використовується для послідовної обробки кожного елемента масиву
//? із збереженням проміжного результату, як акумулятор.
//? Трохи складніший за інші методи для засвоєння,
//? але результат вартий того.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Робить все, що завгодно.
//? 🔸 Повертає що завгодно.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 Перший параметр колбек-функції
//?    (previousValue) - це акумулятор, тобто проміжний результат.
//?    Значення, яке поверне колбек-функція на поточній ітерації,
//?    буде значенням цього параметра на наступній ітерації.
//? 🔹 наступний - значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
//? 🔹 Другий аргумент - необов'язкове початкове значення акумулятора
//?    - параметр initialValue.
console.log(
    `%c
    масив.reduce((previousValue, element, index, array) => {
        // тіло колбек-функції
    }, initialValue);
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода reduce():");
//? ✳️ Найлегше уявити його роботу метода reduce()
//? на прикладі підрахунку суми елементів масиву.
//? ✳️ Спочатку метод reduce()
//? створює внутрішню змінну-акумулятор (previousValue)
//? і присвоює їй значення параметра initialValue
//? або першого елемента масиву, що перебирається,
//? якщо initialValue не задане.
//? 🔹 previousValue = initialValue = 0; (або previousValue = array(0) = 2).
//? Потім колбек - функція викликається для кожного елемента масиву.
//? Поточне значення параметра previousValue
//? - це те, що повернула колбек - функція на минулій ітерації.
//?     🔹 Ітерація 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2
//?     🔹 Ітерація 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9
//?     🔹 Ітерація 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12
//?     🔹 Ітерація 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26
//?     🔹 Ітерація 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32
//? Після завершення перебирання всього масиву, метод reduce() повертає значення акумулятора.
//?       Результат = 32
const array = [2, 7, 3, 14, 6];
const initialValue = 0 ;
console.log("array:", array);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `")

const total = array.reduce((previousValue, number, index) => {
    console.log(`Iteration-${index + 1}:  previousValue: ${previousValue},  number: ${number}  ->  return ${previousValue + number}`);
    return previousValue + number;
}, initialValue);

console.log("total:", total); //! 32
//? ✳️ Тобто метод reduce() використовується,
//? коли необхідно взяти «багато» і привести до «одного».
//? У повсякденних завданнях його застосування зводиться до роботи з числами.
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .")
;
//? ❗️❗️❗️ Важливий приклад вірного використання синтаксису метода reduce():
console.warn("Приклад-1: ВІРНЄ використання синтаксису метода reduce():");
//todo var.1
function example1(arr) {
    arr.reduce((acc, element, index) => {
        console.log(`Acc: ${acc}; Index-${index}:  Element: ${element}`);
    }, 15);
}
example1(["Робітник1", "Робітник2", "Робітник3"]);
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .");

console.warn("Приклад-2: ПОМИЛКОВЕ використання синтаксису метода reduce():");
//todo var.2 
function example2(arr) {
    arr.reduce((element, index) => {
        console.log(`Index-${index}:  Element: ${element}`); //todo var.2
    }, undefined);
};//! index:0 elemet:undefined 
example2(["Робітник1", "Робітник2", "Робітник3"]);
console.log("-------------------------------------------------------------");
